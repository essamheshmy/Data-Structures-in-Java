package Data_Structures_Files.KotlinDataStructures.KotlinSets

/*
الفرق بين LinkedHashSet و HashSet في كوتلن
LinkedHashSet و HashSet هما نوعان من المجموعات (Sets) في كوتلن، وكلاهما يستخدم لتخزين عناصر فريدة (أي لا يتكرر أي عنصر أكثر من مرة). ومع ذلك، فهما يختلفان في الطريقة التي يخزنان بها هذه العناصر وترتيبها.

HashSet
الترتيب: لا يضمن أي ترتيب معين للعناصر. يتم تخزين العناصر بشكل عشوائي بناءً على قيمة هاش (hash) لكل عنصر.
الأداء: عادةً ما يكون أسرع في عمليات الإضافة والحذف والبحث، خاصة للمجموعات الكبيرة.
الاستخدام: يستخدم عندما لا يكون ترتيب العناصر مهمًا والأداء هو الأولوية.
LinkedHashSet
الترتيب: يحافظ على ترتيب الإضافة للعناصر. أي أن العناصر ستظهر بنفس الترتيب الذي أضيفت به.
الأداء: يكون أداءه أبطأ قليلاً من HashSet بسبب الحاجة إلى الحفاظ على ترتيب الإضافة.
الاستخدام: يستخدم عندما يكون الحفاظ على ترتيب الإضافة مهمًا، مثل عندما تحتاج إلى تكرار العناصر بنفس الترتيب الذي أضيفت به.
مثال توضيحي:
*/fun LinkedHashSetVsHashSet() {
    // إنشاء HashSet
    val hashSet = hashSetOf("apple", "banana", "orange")
    println(hashSet) // قد يطبع: [banana, apple, orange] (الترتيب غير مضمون)

    // إنشاء LinkedHashSet
    val linkedHashSet = linkedSetOf("apple", "banana", "orange")
    println(linkedHashSet) // سيطبع: [apple, banana, orange] (نفس ترتيب الإضافة)
}
/*
متى تستخدم أيًا منهما؟

HashSet:
عندما تحتاج إلى مجموعة من العناصر الفريدة ولا تهتم بترتيبها.
عندما يكون الأداء هو الأولوية.
LinkedHashSet:
عندما تحتاج إلى مجموعة من العناصر الفريدة وتحافظ على ترتيب الإضافة.
عندما تحتاج إلى تكرار العناصر بنفس الترتيب الذي أضيفت به.
الفرق بين LinkedHashSet و HashSet في كوتلن
LinkedHashSet و HashSet هما نوعان من المجموعات (Sets) في كوتلن، وكلاهما يستخدم لتخزين عناصر فريدة (أي لا يتكرر أي عنصر أكثر من مرة). ومع ذلك، فهما يختلفان في الطريقة التي يخزنان بها هذه العناصر وترتيبها.

HashSet
الترتيب: لا يضمن أي ترتيب معين للعناصر. يتم تخزين العناصر بشكل عشوائي بناءً على قيمة هاش (hash) لكل عنصر.
الأداء: عادةً ما يكون أسرع في عمليات الإضافة والحذف والبحث، خاصة للمجموعات الكبيرة.
الاستخدام: يستخدم عندما لا يكون ترتيب العناصر مهمًا والأداء هو الأولوية.
LinkedHashSet
الترتيب: يحافظ على ترتيب الإضافة للعناصر. أي أن العناصر ستظهر بنفس الترتيب الذي أضيفت به.
الأداء: يكون أداءه أبطأ قليلاً من HashSet بسبب الحاجة إلى الحفاظ على ترتيب الإضافة.
الاستخدام: يستخدم عندما يكون الحفاظ على ترتيب الإضافة مهمًا، مثل عندما تحتاج إلى تكرار العناصر بنفس الترتيب الذي أضيفت به.
مثال توضيحي:

Kotlin
fun main() {
    // إنشاء HashSet
    val hashSet = hashSetOf("apple", "banana", "orange")
    println(hashSet) // قد يطبع: [banana, apple, orange] (الترتيب غير مضمون)

    // إنشاء LinkedHashSet
    val linkedHashSet = linkedSetOf("apple", "banana", "orange")
    println(linkedHashSet) // سيطبع: [apple, banana, orange] (نفس ترتيب الإضافة)
}
يُرجى استخدام الرمز البرمجي بحذر.

ملخص المقارنة:

الخاصية	HashSet	LinkedHashSet
الترتيب	غير مضمون	يحافظ على ترتيب الإضافة
الأداء	أسرع	أبطأ قليلاً
الاستخدام	عندما لا يهم الترتيب	عندما يكون الحفاظ على الترتيب مهمًا

التصدير إلى "جداول بيانات Google"
متى تستخدم أيًا منهما؟

HashSet:
عندما تحتاج إلى مجموعة من العناصر الفريدة ولا تهتم بترتيبها.
عندما يكون الأداء هو الأولوية.
LinkedHashSet:
عندما تحتاج إلى مجموعة من العناصر الفريدة وتحافظ على ترتيب الإضافة.
عندما تحتاج إلى تكرار العناصر بنفس الترتيب الذي أضيفت به.
مثال آخر:

Kotlin
fun main() {
    val history = linkedSetOf<String>()
    history.add("page1")
    history.add("page2")
    history.add("page1") // لن يتم إضافته مرة أخرى لأنه موجود بالفعل
    println(history) // سيطبع: [page1, page2]
}
يُرجى استخدام الرمز البرمجي بحذر.

في هذا المثال، يتم استخدام LinkedHashSet لتخزين سجل لتاريخ الزيارات لصفحات الويب. حيث يتم الحفاظ على ترتيب الزيارات، مما يسمح باسترجاع الصفحات التي تمت زيارتها بترتيب زمني.

باختصار:

HashSet: مثالي للمجموعات الكبيرة حيث الأداء هو الأولوية.
LinkedHashSet: مثالي عندما تحتاج إلى الحفاظ على ترتيب الإضافة للعناصر.
اختيار النوع المناسب يعتمد على متطلبات التطبيق الخاص بك.
 */